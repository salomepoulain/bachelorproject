from code.classes.UnitcellPartials import Atom, Molecule
from typing import Tuple
import math

class UnitcellBuilder:
    def __init__(self, file_name, replication, height, al_mg_ratio, ca_si_ratio) -> None:
        self.file_name = file_name
        self.height = height
        self.al_mg_ratio = al_mg_ratio
        self.ca_si_ratio = ca_si_ratio
        self.replication: Tuple[int, int] = replication
        
        self.dimensions = ((None, None), (None, None), (None, None))
        self.atoms = []
        self.molecules = []

        self.read_xyz(file_name)
        self.translate_to_zero()
        # self.rescale_coordinates()  # Not sure if needed ?????
        self.expand_and_duplicate()
        self.add_clay_to_molecules()
        self.mg_substitute()
        self.expand_simulation_height()
        self.translate_simulation_height()
        self.add_ions_uniformly()
        self.add_solvent()
        
    def read_xyz(self, file_name):
        file_path = 'input/' + file_name + '.xyz'
        
        with open(file_path, 'r') as file:
            next(file)  
            next(file)
            for line in file:
                parts = line.strip().split()
                if len(parts) == 4:
                    element, x, y, z = parts
                    atom = Atom()
                    atom.element = element
                    atom.position = (float(x), float(y), float(z))
                    self.atoms.append(atom)

        print(f"Read {len(self.atoms)} atoms from {file_name}.xyz")

    def translate_to_zero(self):
        min_x, min_y, min_z = self.atoms[0].position

        for atom in self.atoms:
            x, y, z = atom.position
            min_x = min(min_x, x)
            min_y = min(min_y, y)
            min_z = min(min_z, z)

        for atom in self.atoms:
            x, y, z = atom.position
            atom.position = (x - min_x, y - min_y, z - min_z)
        
        self.get_unit_cell_dimensions()

    def get_unit_cell_dimensions(self):
        if not self.atoms:
            self.dimensions = ((0, 0), (0, 0), (0, 0))
            return
        
        min_x = min_y = min_z = float('inf')
        max_x = max_y = max_z = float('-inf')
        
        for atom in self.atoms:
            x, y, z = atom.position
            min_x = min(min_x, x)
            max_x = max(max_x, x)
            min_y = min(min_y, y)
            max_y = max(max_y, y)
            min_z = min(min_z, z)
            max_z = max(max_z, z)
        
        self.dimensions = ((min_x, max_x), (min_y, max_y), (min_z, max_z))

    def expand_and_duplicate(self):
        original_atoms = list(self.atoms)
        unit_x = self.dimensions[0][1] - self.dimensions[0][0]
        unit_y = self.dimensions[1][1] - self.dimensions[1][0]
        n_x, n_y = self.replication
        
        self.atoms.clear()
        
        for i in range(n_x):
            for j in range(n_y):
                for atom in original_atoms:
                    x, y, z = atom.position
                    new_x = x + i * unit_x
                    new_y = y + j * unit_y

                    new_atom = Atom()
                    new_atom.element = atom.element
                    new_atom.position = (new_x, new_y, z)
                    self.atoms.append(new_atom)
        
        self.get_unit_cell_dimensions()

    def add_clay_to_molecules(self):
        clay = Molecule()
        clay.type = "clay"
        for atom in self.atoms:
            clay.atoms.append(atom)
        self.molecules.append(clay)

    def write_xyz(self, output_file):
        output_path = 'output/' + output_file + '.xyz'
        with open(output_path, 'w') as file:
            file.write(f"{len(self.atoms)}\n")
            file.write("Generated by Unitcell.write_xyz from " + self.file_name + ".xyz\n")
            for atom in self.atoms:
                element = atom.element
                x, y, z = atom.position
                file.write(f"{element} {x} {y} {z}\n")

    # Periodicity?
    def mg_substitute(self):
        substitution_ratio = self.al_mg_ratio  # Aluminium to Magnesium substitution ratio
        fraction = 1 / substitution_ratio
        
        cumulative_fraction = 0.0  # This will track the cumulative addition of fractions
        substitution_count = 0

        # Traverse through the atoms list
        for atom in self.atoms:
            if atom.element == 'Al':
                cumulative_fraction += fraction
                # Check if the cumulative fraction exceeds 1, indicating a substitution
                if cumulative_fraction >= 1:
                    atom.element = 'Mg'
                    substitution_count += 1
                    cumulative_fraction -= 1  # Reset part of the cumulative fraction

        self.write_xyz(self.file_name + "_mg")

    def rescale_coordinates(self):
        target_heigth = 9.6 #aromstrong

        current_heigth = self.dimensions[2]

        scale_factor = target_heigth / current_heigth

        for atom in self.atoms:
            x, y, z = atom.position
            atom.position = (x * scale_factor, y * scale_factor, z * scale_factor)

        self.get_unit_cell_dimensions()

    def expand_simulation_height(self):
        self.dimensions = (self.dimensions[0], self.dimensions[1], (self.dimensions[2][0], self.dimensions[2][0] + self.height))

    def get_clay_height(self):
        zhi = None
        zlo = None
        
        for molecule in self.molecules:
            if molecule.type == 'clay':
                for atom in molecule.atoms:
                    _, _, z = atom.position
                    
                    if zhi is None or zlo is None:
                        zhi = zlo = z
                    else:
                        zhi = max(zhi, z)
                        zlo = min(zlo, z)

            return zhi, zlo

    def translate_simulation_height(self):
        zhi, zlo = self.get_clay_height()
        distance = zhi - zlo
        half_distance = distance / 2   

        self.dimensions = (self.dimensions[0], self.dimensions[1], (self.dimensions[2][0] + half_distance, self.dimensions[2][1] + half_distance))

    def add_solvent(self):
        pass

    def custom_round(self, number):
        if (number - math.floor(number)) < 0.5:
            return int(math.floor(number))
        else:
            return int(math.ceil(number))

    def add_ions_uniformly(self):
        ion_ratio = self.ca_si_ratio
        total_si = len([atom for atom in self.atoms if atom.element == 'Si'])
        ion_count = self.custom_round(total_si * ion_ratio)

        if ion_count == 0:
            return

        ca_height = (self.dimensions[2][0] + self.dimensions[2][1]) / 2
        print(self.dimensions[2])
        print(f"Ca height: {ca_height}")

        n_x = int(ion_count ** 0.5)
        n_y = n_x if n_x * n_x == ion_count else n_x + 1

        x_spacing = (self.dimensions[0][1] - self.dimensions[0][0]) / (n_x if n_x > 1 else 1)
        y_spacing = (self.dimensions[1][1] - self.dimensions[1][0]) / (n_y if n_y > 1 else 1)

        ca_ions_added = 0

        for j in range(n_y):
            for i in range(n_x):
                if ca_ions_added >= ion_count:
                    break
                x = self.dimensions[0][0] + (i * x_spacing) % (self.dimensions[0][1] - self.dimensions[0][0])
                y = self.dimensions[1][0] + (j * y_spacing) % (self.dimensions[1][1] - self.dimensions[1][0])

                atom = Atom()
                atom.element = 'Ca'
                atom.position = (x, y, ca_height)
                self.atoms.append(atom)
                
                ion = Molecule()
                ion.type = 'ion'
                ion.atoms.append(atom)
                self.molecules.append(ion)

                ca_ions_added += 1

        self.write_xyz(self.file_name + "_mg_ion")


        for molecule in self.molecules:
            if molecule.type == 'clay':
                print(len(molecule.atoms))

    def displace_simulation_box(self):
        for molecule in self.molecules:
            if molecule.type == "clay":
                pass


    # def calculate(self):
    #     list = []
    #     for atom in self.atoms:
    #         if atom.element == 'H':
    #             list.append(atom)

    #     print(f"Number of H atoms: {len(list)}")



    '''
    Function to trim the structure, used for creating the first unit cell
    '''
    def trim_structure(self):
        x_trim_start = -2.876
        x_trim_end = 2.316
        y_trim_start = -7.664
        y_trim_end = 1.351
        
        self.atoms = [atom for atom in self.atoms if x_trim_start <= atom.position[0] < x_trim_end and y_trim_start <= atom.position[1] < y_trim_end]
        
        unit_x = (x_trim_start, x_trim_end)
        unit_y = (y_trim_start, y_trim_end)
        unit_z = self.dimensions[2]  # Assumes z-dimension is unaffected by trimming
        
        self.dimensions = (unit_x, unit_y, unit_z)

        print(f"New dimensions: {self.dimensions}")
        print(f"Number of atoms after trimming: {len(self.atoms)}")
        
        output_file_name = self.file_name + "_trim.xyz"
        self.write_xyz(output_file_name)



